import type { Express } from "express";
import { storage } from "../storage";
import { insertTimeEntrySchema, updateTimeEntrySchema } from "@shared/schema";
import { z } from "zod";

export function registerTimeTrackingRoutes(app: Express): void {
  app.get("/api/time-entries", async (req, res) => {
    try {
      const { matterId } = req.query;
      const entries = await storage.getTimeEntries(matterId as string | undefined);
      res.json(entries);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch time entries" });
    }
  });

  app.get("/api/time-entries/:id", async (req, res) => {
    try {
      const entry = await storage.getTimeEntry(req.params.id);
      if (!entry) {
        return res.status(404).json({ error: "Time entry not found" });
      }
      res.json(entry);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch time entry" });
    }
  });

  app.post("/api/time-entries", async (req, res) => {
    try {
      const dbUser = (req as any).dbUser;
      const body = {
        ...req.body,
        userId: dbUser?.id || req.body.userId || "unknown",
        userName: dbUser ? `${dbUser.firstName || ""} ${dbUser.lastName || ""}`.trim() || dbUser.email : req.body.userName || "Unknown User",
      };
      const data = insertTimeEntrySchema.parse(body);
      const entry = await storage.createTimeEntry(data);

      try {
        await storage.createTimelineEvent({
          matterId: entry.matterId,
          eventType: "custom",
          title: `Time Entry: ${entry.description}`,
          description: `${entry.hours}h ${entry.billableStatus === "billable" ? "(billable" + (entry.hourlyRate ? ` @ $${entry.hourlyRate}/hr` : "") + ")" : "(non-billable)"} by ${entry.userName}`,
          createdBy: entry.userId,
          eventDate: entry.date,
          metadata: {
            timeEntryId: entry.id,
            hours: entry.hours,
            billableStatus: entry.billableStatus,
            hourlyRate: entry.hourlyRate,
            activityCode: entry.activityCode,
            autoGenerated: true,
            sourceEntity: "time_entry",
          },
        });
      } catch (_e) {}

      if (entry.billableStatus === "billable" && entry.matterId) {
        try {
          const matter = await storage.getMatter(entry.matterId);
          if (matter) {
            const boards = await storage.getBoardsByMatter(entry.matterId);
            for (const board of boards) {
              const automationEvent = {
                type: "item_created",
                boardId: board.id,
                metadata: {
                  source: "time_entry",
                  timeEntryId: entry.id,
                  matterId: entry.matterId,
                  clientId: matter.clientId,
                  hours: entry.hours,
                  amount: entry.hours * (entry.hourlyRate || 350),
                  description: entry.description,
                },
              };
              try {
                const { triggerAutomation } = await import("../automation-engine");
                await triggerAutomation(automationEvent);
              } catch (_e) {}
            }
          }
        } catch (_e) {}
      }

      res.status(201).json(entry);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors });
      }
      res.status(500).json({ error: "Failed to create time entry" });
    }
  });

  app.patch("/api/time-entries/:id", async (req, res) => {
    try {
      const data = updateTimeEntrySchema.parse(req.body);
      const entry = await storage.updateTimeEntry(req.params.id, data);
      if (!entry) {
        return res.status(404).json({ error: "Time entry not found" });
      }
      res.json(entry);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors });
      }
      res.status(500).json({ error: "Failed to update time entry" });
    }
  });

  app.delete("/api/time-entries/:id", async (req, res) => {
    try {
      await storage.deleteTimeEntry(req.params.id);
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ error: "Failed to delete time entry" });
    }
  });
}
